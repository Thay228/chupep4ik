СИСЬКИ ЖОПА СИСЬКУИ ЖОПАААА
----------------------------------------------------------------------------------------------------------
1)
package main

import (
	"fmt"
	"sync"
)

var counter int
var mu sync.Mutex

func increment(wg *sync.WaitGroup) {
	defer wg.Done()
	mu.Lock()
	counter++
	fmt.Println("Обновился счёстчик", counter)
	mu.Unlock()
}

func main() {
	wg := &sync.WaitGroup{}
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go increment(wg)
	}
	wg.Wait()
	fmt.Println("Result:", counter)
	//Обновился счёстчик 1
	//Обновился счёстчик 2
	//Обновился счёстчик 3
	//Обновился счёстчик 4
	//Обновился счёстчик 5
	//Обновился счёстчик 6
	//Обновился счёстчик 7
	//Обновился счёстчик 8
	//Обновился счёстчик 9
	//Обновился счёстчик 10
	//Result: 10
}
----------------------------------------------------------------------------------------------------------
2)
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

var counter int32

func increment(wg *sync.WaitGroup) {
	defer wg.Done()
	atomic.AddInt32(&counter, 1)
}

func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go increment(&wg)
	}
	wg.Wait()
	fmt.Println("Result:", counter)
}
----------------------------------------------------------------------------------------------------------
3)
package main

import (
	"fmt"
	"math/rand"
	"sync"
)

var wg sync.WaitGroup

func sumPart(nums []int, resultCh chan int) {
	defer wg.Done()
	s := 0
	for _, x := range nums {
		s += x
	}
	resultCh <- s
}

func main() {
	const parts = 10
	nums := make([]int, 1000)
	for i := range nums {
		nums[i] = rand.Intn(100)
	}
	resultCh := make(chan int, parts)

	tb := 0
	for i := 0; i < parts; i++ {
		wg.Add(1)
		go sumPart(nums[i*100:(i+1)*100], resultCh)
	}

	wg.Wait()
	close(resultCh)

	for s := range resultCh {
		tb += s
	}

	fmt.Println(tb)
}
----------------------------------------------------------------------------------------------------------
4)
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func generator(ch chan int) {
	defer wg.Done()
	for i := 1; i < 6; i++ {
		ch <- i
	}
	close(ch)
}

func consumer(ch chan int) {
	defer wg.Done()
	for i := range ch {
		fmt.Println(i)
	}
}

func main() {
	ch := make(chan int)
	wg.Add(2)
	go generator(ch)
	go consumer(ch)
	wg.Wait()
}
----------------------------------------------------------------------------------------------------------
5)
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func producer(ch chan int) {
	defer wg.Done()
	for i := 1; i < 6; i++ {
		ch <- i
	}
	close(ch)
}

func square(ch1, ch2 chan int) {
	defer wg.Done()
	defer close(ch2)
	for i := range ch1 {
		ch2 <- i * i
	}

}

func printer(ch chan int) {
	defer wg.Done()
	for i := range ch {
		fmt.Println(i)
	}
}

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	wg.Add(3)
	go producer(ch1)
	go square(ch1, ch2)
	go printer(ch2)
	wg.Wait()
}
----------------------------------------------------------------------------------------------------------
6)
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
	defer wg.Done()

	ticke := time.NewTicker(1 * time.Second)
	defer ticke.Stop()
	for {
		select {
		case <-ticke.C:
			fmt.Println("tick")
		case <-ctx.Done():
			return
		}
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	wg.Add(1)
	go worker(ctx)
	wg.Wait()
}
----------------------------------------------------------------------------------------------------------
7)
package main

import (
	"context"
	"fmt"
	"math/rand"
	"sync"
	"time"
)

var wg sync.WaitGroup

func rut(ctx context.Context, ch chan string, i int) {
	defer wg.Done()

	n := time.Duration(rand.Intn(500)+100) * time.Millisecond
	time.Sleep(n)
	select {
	case ch <- fmt.Sprintf("Горутина %d (%v) ВСЁ", i, n):
	case <-ctx.Done():
		return
	}
}

func main() {
	chck := make(chan string, 2)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	wg.Add(2)
	go rut(ctx, chck, 1)
	go rut(ctx, chck, 2)

	g1 := <-chck
	fmt.Println(g1)
	cancel()

	select {
	case g2 := <-chck:
		fmt.Println(g2)
	default:
		fmt.Println("Вторая горутина была отменена")
	}
}
----------------------------------------------------------------------------------------------------------
8)
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

var wg sync.WaitGroup

type SafeNumber struct {
	value int
	mu    sync.RWMutex
}

func (s *SafeNumber) Get() int {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.value
}

func (s *SafeNumber) Set(v int) {
	s.mu.Lock()
	s.value = s.value + v
	s.mu.Unlock()
}
func main() {
	n := rand.Intn(107)
	iV := n
	sfn := SafeNumber{
		value: n,
		mu:    sync.RWMutex{},
	}
	for i := 0; i < 6; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 3; j++ {
				sfn.Get()
				time.Sleep(time.Millisecond * 100)

			}
		}()
	}

	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			time.Sleep(time.Second)
			sfn.Set(rand.Intn(100))
		}
	}()

	wg.Wait()
	fmt.Println(sfn.value, iV)
}
----------------------------------------------------------------------------------------------------------
9)





















