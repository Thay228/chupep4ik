СИСЬКИ ЖОПА СИСЬКУИ ЖОПАААА
----------------------------------------------------------------------------------------------------------
1)
package main

import (
	"fmt"
	"sync"
)

var counter int
var mu sync.Mutex

func increment(wg *sync.WaitGroup) {
	defer wg.Done()
	mu.Lock()
	counter++
	fmt.Println("Обновился счёстчик", counter)
	mu.Unlock()
}

func main() {
	wg := &sync.WaitGroup{}
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go increment(wg)
	}
	wg.Wait()
	fmt.Println("Result:", counter)
	//Обновился счёстчик 1
	//Обновился счёстчик 2
	//Обновился счёстчик 3
	//Обновился счёстчик 4
	//Обновился счёстчик 5
	//Обновился счёстчик 6
	//Обновился счёстчик 7
	//Обновился счёстчик 8
	//Обновился счёстчик 9
	//Обновился счёстчик 10
	//Result: 10
}
----------------------------------------------------------------------------------------------------------
2)
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

var counter int32

func increment(wg *sync.WaitGroup) {
	defer wg.Done()
	atomic.AddInt32(&counter, 1)
}

func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go increment(&wg)
	}
	wg.Wait()
	fmt.Println("Result:", counter)
}
----------------------------------------------------------------------------------------------------------
3)
package main

import (
	"fmt"
	"math/rand"
	"sync"
)

var wg sync.WaitGroup

func sumPart(nums []int, resultCh chan int) {
	defer wg.Done()
	s := 0
	for _, x := range nums {
		s += x
	}
	resultCh <- s
}

func main() {
	const parts = 10
	nums := make([]int, 1000)
	for i := range nums {
		nums[i] = rand.Intn(100)
	}
	resultCh := make(chan int, parts)

	tb := 0
	for i := 0; i < parts; i++ {
		wg.Add(1)
		go sumPart(nums[i*100:(i+1)*100], resultCh)
	}

	wg.Wait()
	close(resultCh)

	for s := range resultCh {
		tb += s
	}

	fmt.Println(tb)
}
----------------------------------------------------------------------------------------------------------
4)
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func generator(ch chan int) {
	defer wg.Done()
	for i := 1; i < 6; i++ {
		ch <- i
	}
	close(ch)
}

func consumer(ch chan int) {
	defer wg.Done()
	for i := range ch {
		fmt.Println(i)
	}
}

func main() {
	ch := make(chan int)
	wg.Add(2)
	go generator(ch)
	go consumer(ch)
	wg.Wait()
}
----------------------------------------------------------------------------------------------------------
5)
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func producer(ch chan int) {
	defer wg.Done()
	for i := 1; i < 6; i++ {
		ch <- i
	}
	close(ch)
}

func square(ch1, ch2 chan int) {
	defer wg.Done()
	defer close(ch2)
	for i := range ch1 {
		ch2 <- i * i
	}

}

func printer(ch chan int) {
	defer wg.Done()
	for i := range ch {
		fmt.Println(i)
	}
}

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	wg.Add(3)
	go producer(ch1)
	go square(ch1, ch2)
	go printer(ch2)
	wg.Wait()
}
----------------------------------------------------------------------------------------------------------
6)
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
	defer wg.Done()

	ticke := time.NewTicker(1 * time.Second)
	defer ticke.Stop()
	for {
		select {
		case <-ticke.C:
			fmt.Println("tick")
		case <-ctx.Done():
			return
		}
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	wg.Add(1)
	go worker(ctx)
	wg.Wait()
}
----------------------------------------------------------------------------------------------------------
7)























