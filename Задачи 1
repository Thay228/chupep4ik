1)
package main

import (
	"errors"
	"fmt"
)

func secondMax(sex []int) (int, error) {
	if len(sex) < 2 {
		return 0, errors.New("–¢–´ –ï–ë–ê–ù–£–¢–´?")
	}
	max1, max2 := sex[1], sex[0]
	if max1 < max2 {
		max1, max2 = max2, max1
	}
	for i := 2; i < len(sex); i++ {
		if sex[i] > max1 {
			max2 = max1
			max1 = sex[i]
		}else if (sex[i] > max2 && sex[i] < max1) || (max2 == max1 && sex[i] < max1) {
			max2 = sex[i]
		}
	}
	return max2, nil
}

func main() {
	fmt.Println(secondMax([]int{10, 20})) //10
	fmt.Println(secondMax([]int{20, 10})) //10    
	fmt.Println(secondMax([]int{5, 5, 1})) //1   
	fmt.Println(secondMax([]int{10, 5, 10})) //5
	fmt.Println(secondMax([]int{-10, -5, 0})) //-5
}
----------------------------------------------------------------------------------------------------------
2)
package main

import (
	"fmt"
	"sort"
)

func mergeAndSort(arr1, arr2 []int) []int {
	arr3 := append(arr1, arr2...)
	sort.Ints(arr3)
	return arr3
}

func main() {
	fmt.Println(mergeAndSort([]int{3, 1, 5}, []int{4, 2, 6})) // [1 2 3 4 5 6]
	fmt.Println(mergeAndSort([]int{8, 2, 0}, []int{7, 3, 1})) // [0 1 2 3 7 8]
}
----------------------------------------------------------------------------------------------------------
3)
package main

import "fmt"

func isLeapYear(y int) bool {
	ya := false
	if (y%4 == 0 && y%100 != 0) || (y%400 == 0) {
		ya = true
	}
	return ya
}

func main() {
	fmt.Println(isLeapYear(2020)) // true
	fmt.Println(isLeapYear(1900)) // false
	fmt.Println(isLeapYear(2000)) // true

}
----------------------------------------------------------------------------------------------------------
4)
package main

import (
	"fmt"
)

func maxOfThree(a, b, c int) int {
	max := a

	if b > max {
		max = b
	}

	if c > max {
		max = c
	}

	return max
}

func main() {
	fmt.Println(maxOfThree(3, 7, 5))  // 7
	fmt.Println(maxOfThree(10, 2, 8)) // 10

}
----------------------------------------------------------------------------------------------------------
5)
package main

import (
	"fmt"
)

func reverseSTR(a string) string {
	length := len(a)

	b := make([]rune, length)

	for i, r := range a {
		b[length-1-i] = r
	}

	return string(b)
}

func main() {
	fmt.Println(reverseSTR("hello"))  // "olleh"
	fmt.Println(reverseSTR("–ü—Ä–∏–≤–µ—Ç")) // "—Ç–µ–≤–∏—Ä–ü"
	fmt.Println(reverseSTR("Hai"))    // "iaH"
	fmt.Println(reverseSTR("–°–æ—Å–∞–ª"))  // "–ª–∞—Å–æ–°"

}
----------------------------------------------------------------------------------------------------------
6)
package main

import "fmt"

func charCase(r rune) string {
	if r >= '–∞' && r <= '—è' || r == '—ë' {
		return "–ö–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–æ—á–Ω–∞—è"
	} else if r >= '–ê' && r <= '–Ø' || r == '–Å' {
		return "–ö–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≥–ª–∞–≤–Ω–∞—è"
	} else if r >= 'A' && r <= 'Z' {
		return "–õ–∞—Ç–∏–Ω—Å–∫–∞—è –∑–∞–≥–ª–∞–≤–Ω–∞—è"
	} else if r >= 'a' && r <= 'z' {
		return "–õ–∞—Ç–∏–Ω—Å–∫–∞—è —Å—Ç—Ä–æ—á–Ω–∞—è"
	}

	return "–î—Ä—É–≥–æ–µ"
}

func main() {
	fmt.Println(charCase('A')) // "–õ–∞—Ç–∏–Ω—Å–∫–∞—è –∑–∞–≥–ª–∞–≤–Ω–∞—è"
	fmt.Println(charCase('—è')) // "–ö–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–æ—á–Ω–∞—è"
	fmt.Println(charCase('–ë')) // "–ö–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≥–ª–∞–≤–Ω–∞—è"
	fmt.Println(charCase('1')) // "–î—Ä—É–≥–æ–µ"
	fmt.Println(charCase('üòä')) // "–î—Ä—É–≥–æ–µ"
}
----------------------------------------------------------------------------------------------------------
7)
package main

import "fmt"

func calculator(a, b int, op string) (int, error) {

	switch op {
	case "+":
		return a + b, nil
	case "-":
		return a - b, nil
	case "*":
		return a * b, nil
	case "/":
		if b == 0 {
			return 0, fmt.Errorf("–∞—à–∞–ª–µ, —Ç—ã –∑–∞—á–µ–º –Ω–∞ 0 —Ç–æ –¥–µ–ª–∏—à—å")
		} else {
			return a / b, nil
		}
	}

	return 0, fmt.Errorf("–æ–π –±–∞–ª—è, —è –Ω–µ –ø–æ–Ω–∏–º–∞—é —á—ë —Ç—ã —Ö–æ—á–µ—à—å")

}

func main() {
	fmt.Println(calculator(10, 5, "+")) // 15
	fmt.Println(calculator(10, 5, "-")) // 5
	fmt.Println(calculator(10, 5, "*")) // 50
	fmt.Println(calculator(10, 0, "/")) // 0

}
----------------------------------------------------------------------------------------------------------
8)
package main

import "fmt"

func sumToN(n int) int {
	c := 0
	for i := 1; i <= n; i++ {
		c += i
	}

	return c
}

func main() {
	fmt.Println(sumToN(5))  // 15 (1 + 2 + 3 + 4 + 5)
	fmt.Println(sumToN(10)) // 55

}
----------------------------------------------------------------------------------------------------------
9)
package main

import (
	"fmt"
	"strconv"
)

func reverseNumber(n int) (int, error) {
	c := strconv.Itoa(n)
	r := []rune(c)
	for i, j := 0, len(c)-1; i < j; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	if c[0] == '-' {
		r, err := strconv.Atoi("-" + string(r[:len(r)-1]))
		return r, err
	}
	return strconv.Atoi(string(r))
}

func main() {
	fmt.Println(reverseNumber(123))  // 321
	fmt.Println(reverseNumber(500))  // 5
	fmt.Println(reverseNumber(-987)) // -789
	fmt.Println(reverseNumber(-100)) // -1
}
----------------------------------------------------------------------------------------------------------
10)
package main

import (
	"fmt"
)

func sequenceGenerator() func() int {
	k := 0
	return func() int {
		k += 1
		return k
	}
}

func main() {
	next := sequenceGenerator()
	fmt.Println(next()) // 1
	fmt.Println(next()) // 2
	fmt.Println(next()) // 3

}
----------------------------------------------------------------------------------------------------------
11)
package main

import (
	"fmt"
	"math"
)

func powerFunc(su int) func(int) int {
	return func(c int) int {
		return int(math.Round(math.Pow(float64(c), float64(su))))
	}
}

func main() {
	square := powerFunc(2)
	fmt.Println(square(-3)) //9
	fmt.Println(square(5))  // 25
	cube := powerFunc(3)
	fmt.Println(cube(2)) // 8
	fmt.Println(cube(3)) // 27

}
----------------------------------------------------------------------------------------------------------
12)
package main

import (
	"fmt"
)

func swap(a, b *int) {
	*a, *b = *b, *a
}

func main() {
	x, y := 10, 20
	swap(&x, &y)
	fmt.Println(x, y) // 20 10
	swap(&x, &y)
	fmt.Println(x, y) // 10 20

}
----------------------------------------------------------------------------------------------------------
13)
package main

import (
	"fmt"
)

func increment(ptr *int) {
	*ptr = *ptr + 1
}

func main() {
	n := 5
	increment(&n)
	fmt.Println(n) // 6
	increment(&n)
	increment(&n)
	increment(&n)
	fmt.Println(n) // 9
}
----------------------------------------------------------------------------------------------------------
14)
package main

import (
	"fmt"
)

func appendValue(slice *[]int, value int) {
	*slice = append(*slice, value)
}

func main() {
	nums := []int{1, 2, 3}
	appendValue(&nums, 4)
	fmt.Println(nums) // [1 2 3 4]
	mk := []int{}
	appendValue(&mk, 5)
	fmt.Println(mk) // [5]
}


func appendValue1(slice []int, value int) []int {
    return append(slice, value)}

func main() {
	nums := []int{1, 2, 3}
	nums = appendValue1(nums, 4)
	fmt.Println(nums) // [1 2 3 4]
	mk := []int{}
	mk = appendValue1(mk, 5)
	fmt.Println(mk) // [5]
}
----------------------------------------------------------------------------------------------------------
15)
package main

import (
	"fmt"
)

func removeAtIndex(arr []int, index int) []int {
	if len(arr) < index {
		return arr
	}

	return append(arr[:index], arr[index+1:]...)
}

func main() {
	fmt.Println(removeAtIndex([]int{1, 2, 3, 4, 5}, 2)) // [1 2 4 5]
	fmt.Println(removeAtIndex([]int{10, 20, 30}, 5))    // [10 20 30]
}
----------------------------------------------------------------------------------------------------------
16)
package main

import (
	"fmt"
)

func safeDivide(a, b int) (re int) {
	defer func() {
		if r := recover(); r != nil {
			re = 0
		}
	}()

	return a / b
}

func main() {
	fmt.Println(safeDivide(10, 2)) // 5
	fmt.Println(safeDivide(10, 0)) // 0 (–≤–º–µ—Å—Ç–æ –ø–∞–Ω–∏–∫–∏)
}
----------------------------------------------------------------------------------------------------------
17)
package main

import (
	"fmt"
)

func safeFunction(f func()) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("–û—à–∏–±–∫–∞:", r)
		}
	}()
	f()
}

func main() {
	safeFunction(func() {
		fmt.Println("–í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–¥...")
		//panic("—á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫")
		//fmt.Println("–í—Å—ë —á—ë—Ç–∫–æ –±—Ä–∞—Ç")
		x := 0
		fmt.Println(15 / x)
	})
}
----------------------------------------------------------------------------------------------------------
18)
package main

import (
	"fmt"
	"strings"
)

func wordCount(s string) map[string]int {
	ku := map[string]int{}
	pi := strings.Fields(s)
	for _, y := range pi {
		c := strings.ToLower(strings.Trim(y, "!@#$%^&*(),.?"))
		ku[c]++
	}
	return ku

}

func main() {
	fmt.Println(wordCount("Hello, hello world! Hello world.")) // map[hello:3 world:2]
	
}
----------------------------------------------------------------------------------------------------------
19)
package main

import (
	"fmt"
)

func invertMap(m map[string]int) map[int]string {
	n := map[int]string{}
	for i, y := range m {
		n[y] = i
	}
	return n
}

func main() {
	m := map[string]int{"a": 1, "b": 2, "c": 1}
	fmt.Println(invertMap(m)) // map[1:"a" –∏–ª–∏ "c", 2:"b"]
}
----------------------------------------------------------------------------------------------------------
20)
package main

import (
	"fmt"
)

func mergeMaps(m1, m2 map[string]int) map[string]int {
	for ki := range m1 {
		m2[ki] = m1[ki] + m2[ki]
	}
	return m2
}

func main() {
	m1 := map[string]int{"apple": 5, "banana": 3}
	m2 := map[string]int{"banana": 2, "orange": 4}
	fmt.Println(mergeMaps(m1, m2)) // map[apple:5 banana:5 orange:4]
}
----------------------------------------------------------------------------------------------------------
21)
package main

import (
	"fmt"
)

type Rectangle struct {
	Width  float64
	Height float64
}

func (a Rectangle) Area() float64 {
	return a.Width * a.Height
}

func main() {
	r := Rectangle{Width: 5, Height: 10}
	fmt.Println(r.Area()) // 50
}
----------------------------------------------------------------------------------------------------------
22)
package main

import (
	"errors"
	"fmt"
)

type Product struct {
	ID       int64
	Name     string
	Price    float64
	Quantity int64
}

type Inventory struct {
	Products map[int64]Product
}

func NewInventory() Inventory {
	return Inventory{
		Products: make(map[int64]Product),
	}
}

func (in Inventory) AddProduct(p Product) {
	in.Products[p.ID] = p
}

func (in *Inventory) SellProduct(id, qty int64) error {
	if prod, ok := in.Products[id]; ok {
		if prod.Quantity >= qty {
			prod.Quantity = prod.Quantity - qty
			in.Products[id] = prod
			return nil
		} else {
			return errors.New("–û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–≤–∞—Ä–∞")
		}
	} else {
		return errors.New("–û—à–∏–±–∫–∞: —Ç–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω")
	}
}

func main() {
	inv := NewInventory()
	inv.AddProduct(Product{ID: 1, Name: "–¢–µ–ª–µ—Ñ–æ–Ω", Price: 30000, Quantity: 10})
	fmt.Println(inv.SellProduct(1, 3)) // nil
	fmt.Println(inv.SellProduct(1, 8)) // –û—à–∏–±–∫–∞: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–≤–∞—Ä–∞
}
----------------------------------------------------------------------------------------------------------
23)
package main

import (
	"errors"
	"fmt"
)

type Ticket struct {
	ID            int64
	PassengerName string
	Destination   string
}

type BookingSystem struct {
	//mu      sync.Mutex      // –î–æ–±–∞–≤–ª—è–µ–º –º—å—é—Ç–µ–∫—Å
	Tickets map[int64]Ticket
}

func NewBookingSystem() BookingSystem {
	return BookingSystem{
		Tickets: map[int64]Ticket{},
	}
}

func (bs *BookingSystem) BookTicket(id int64, name, destination string) error {
	//bs.mu.Lock()         // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞
	//defer bs.mu.Unlock() // –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
	if _, ok := bs.Tickets[id]; ok {
		return errors.New("–û—à–∏–±–∫–∞: –±–∏–ª–µ—Ç —Å —Ç–∞–∫–∏–º ID —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
	}
	bs.Tickets[id] = Ticket{
		ID:            id,
		PassengerName: name,
		Destination:   destination,
	}
	return nil
}

func (bs *BookingSystem) CancelTicket(id int64) error {
	// bs.mu.Lock()         // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –≤ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ
	// defer bs.mu.Unlock() // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
	if _, ok := bs.Tickets[id]; ok {
		delete(bs.Tickets, id)
		return nil
	}

	return errors.New("–û—à–∏–±–∫–∞: –±–∏–ª–µ—Ç —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
}

func (bs BookingSystem) GetTicket(id int64) (Ticket, error) {
	// bs.mu.Lock()         // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è —á—Ç–µ–Ω–∏—è –≤ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ
	// defer bs.mu.Unlock() // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
	if ticket, ok := bs.Tickets[id]; ok {
		return ticket, nil
	}
	return Ticket{}, errors.New("–û—à–∏–±–∫–∞: –±–∏–ª–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
}

func main() {
	bs := NewBookingSystem()
	bs.BookTicket(1, "–ò–≤–∞–Ω", "–ú–æ—Å–∫–≤–∞")
	fmt.Println(bs.GetTicket(1))    // {1 –ò–≤–∞–Ω –ú–æ—Å–∫–≤–∞}, nil
	fmt.Println(bs.CancelTicket(1)) // nil
	fmt.Println(bs.GetTicket(1))    // –û—à–∏–±–∫–∞: –±–∏–ª–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
}
----------------------------------------------------------------------------------------------------------
24)
package main

import (
	"fmt"
	"regexp"
	"strings"
)

type TextProcessor struct {
	Text string
}

func (te *TextProcessor) WordCount() map[string]int {
	re := regexp.MustCompile(`[\p{P}\p{S}]+`)
	up_nest := strings.Fields(re.ReplaceAllString(te.Text, ""))
	map_nest := make(map[string]int, len(up_nest))
	for _, y := range up_nest {
		vs := strings.ToLower(y)
		map_nest[vs]++
	}
	return map_nest
}

func (te *TextProcessor) ReplaceWord(old, new string) {
	re := regexp.MustCompile(`([!?.]\s*)([a-z])`)
	nest := strings.ReplaceAll(strings.ToLower(te.Text), old, new)
	chao := re.ReplaceAllStringFunc(nest, func(sm string) string {
		pats := re.FindStringSubmatch(sm)
		if len(pats) < 3 {
			return sm
		}
		return pats[1] + strings.ToUpper(pats[2])
	})
	te.Text = strings.ToUpper(chao[:1]) + chao[1:]
}

func main() {
	tp := TextProcessor{"Hello world, hello again! hello everyone!!!"}
	fmt.Println(tp.WordCount()) // map[hello:2 world:1 again:1]
	tp.ReplaceWord("hello", "hi")
	fmt.Println(tp.Text) // "Hi world, hi again! Hi everyone!!!."
}
----------------------------------------------------------------------------------------------------------
25)










